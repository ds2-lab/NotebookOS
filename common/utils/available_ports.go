package utils

import (
	"errors"
	"fmt"
	"github.com/Scusemua/go-utils/config"
	"github.com/Scusemua/go-utils/logger"
	"sync"
)

// AvailablePorts is a thread-safe data structure that keeps track of a set of ports to be used by ZMQ sockets for listening.
// Entities can request ports from this data structure, which will then be allocated to the entity for
// exclusive use until they are returned by the original owner.
type AvailablePorts struct {
	log logger.Logger

	startingPort     int          // The lowest-numbered port available.
	totalNumPorts    int          // The total number of ports available.
	ports            []int        // List of all the ports managed by this struct. Does not change.
	availablePorts   []int        // The ports that are available.
	allocationSize   int          // Number of ports that will be requested/allocated at a single time.
	portAvailability map[int]bool // Used to efficiently check if a given port is available or not (rather than iterating over the list).
	mu               sync.Mutex

	maxPort int // The largest port managed by this struct.

	// Metrics.
	numAllocations int // Number of calls to AvailablePorts::RequestPorts
	numReturns     int // Number of calls to AvailablePorts::ReturnPorts
}

var (
	ErrInsufficientPortsAvailable = errors.New("there are not enough available ports to satisfy the request")
	ErrInvalidPortReturned        = errors.New("one or more of the specified ports were not marked as unavailable")
)

// NewAvailablePorts construct a new AvailablePorts data structure. Returns a pointer to the data structure.
//
// Parameters:
//   - startingPort: The first port in the collection. Must be >= 1,024.
//   - totalNumPorts: The total number of ports to be available in the collection, beginning with the first port and ending with startingPort + totalNumPorts. Must be a positive (non-zero) value.
//   - allocationSize: The number of ports that will be requested/allocated at a single time. Must be a positive (i.e., non-zero) value.
//
// If either of the two parameters are invalid (based on the requirements specified above), then this function panics.
// If the range of ports generated by the provided starting port and total number of ports is invalid (i.e., one or more ports exceed
// the maximum TCP port of 65,535), then this function panics.
func NewAvailablePorts(startingPort int, totalNumPorts int, allocationSize int) *AvailablePorts {
	if startingPort <= 1023 {
		panic(fmt.Sprintf("Invalid starting port: %d", startingPort))
	}

	if totalNumPorts <= 0 {
		panic(fmt.Sprintf("Invalid value specified for the total number of ports: %d", totalNumPorts))
	}

	if allocationSize <= 0 {
		panic(fmt.Sprintf("Invalid value specified for the 'allocation size': %d", allocationSize))
	}

	availablePorts := &AvailablePorts{
		startingPort:     startingPort,
		totalNumPorts:    totalNumPorts,
		allocationSize:   allocationSize,
		maxPort:          startingPort + totalNumPorts,
		portAvailability: make(map[int]bool),
		ports:            make([]int, 0, totalNumPorts),
		availablePorts:   make([]int, 0, totalNumPorts),
	}
	config.InitLogger(&availablePorts.log, availablePorts)

	if availablePorts.maxPort > 65535 {
		panic(fmt.Sprintf("Invalid or illegal range of ports specified: %d - %d.", startingPort, startingPort+totalNumPorts))
	}

	for i := startingPort; i < (startingPort + totalNumPorts); i++ {
		availablePorts.ports = append(availablePorts.ports, i)

		// All ports are initially available.
		availablePorts.availablePorts = append(availablePorts.availablePorts, i)
		availablePorts.portAvailability[i] = true
	}

	return availablePorts
}

func (p *AvailablePorts) String() string {
	return fmt.Sprintf("AvailablePorts[Total: %d. Currently Available: %d.]", p.TotalNumPorts(), p.NumPortsAvailable())
}

// TotalNumPorts returns the total number of ports managed by this collection.
func (p *AvailablePorts) TotalNumPorts() int {
	return p.totalNumPorts
}

// NumPortsAvailable returns the number of ports currently available.
func (p *AvailablePorts) NumPortsAvailable() int {
	return len(p.availablePorts)
}

// NumPortsAllocated returns the number of ports currently allocated (and thus unavailable).
func (p *AvailablePorts) NumPortsAllocated() int {
	return p.totalNumPorts - len(p.availablePorts)
}

// AllocationSize returns the allocation size.
func (p *AvailablePorts) AllocationSize() int {
	return p.allocationSize
}

// RequestPorts requests `allocationSize` ports from the AvailablePorts data structure.
// Returns an integer slice and an error.
// If there are not enough available ports to satisfy the request, then an error will be returned, and the returned slice will be nil.
// The slice will contain the ports allocated to the caller.
func (p *AvailablePorts) RequestPorts() ([]int, error) {
	p.mu.Lock()
	defer p.mu.Unlock()

	if p.allocationSize > len(p.availablePorts) {
		p.log.Error("Insufficient ports remaining to satisfy request.")
		p.log.Error("Specifically, %d/%d port(s) are allocated. Cannot satisfy request for %d additional port(s).",
			p.NumPortsAllocated(), p.totalNumPorts, p.allocationSize)
		return nil, ErrInsufficientPortsAvailable
	}

	allocation := p.availablePorts[0:p.allocationSize]
	p.availablePorts = p.availablePorts[p.allocationSize:]

	for _, port := range allocation {
		if p.portAvailability[port] == false {
			panic(fmt.Sprintf("Port %d is already marked as unavailable.", port))
		}

		p.portAvailability[port] = false
	}

	p.log.Debug("Returning allocation of %d port(s). Currently %d/%d ports are allocated.",
		p.allocationSize, p.NumPortsAllocated(), p.totalNumPorts)
	return allocation, nil
}

// ReturnPorts accepts as a parameter a slice of integers. These are ports that were allocated to the caller.
// They will be marked as available. Returns an error if any of the ports in the collection were not reserved.
// If the ports slice is empty, then this returns immediately without error.
// If the ports slice is non-empty, it should have size `p.allocationSize`. If the slice has some positive, non-zero size that is not equal to `p.allocationSize`, then this function panics.
// If the ports slice is nil, then this function panics.
//
// If any of the returned ports are already available or not within the valid port range, then this panics.
func (p *AvailablePorts) ReturnPorts(ports []int) error {
	p.mu.Lock()
	defer p.mu.Unlock()

	if ports == nil {
		panic("The provided 'ports' slice should not be null.")
	}

	if len(ports) == 0 {
		return nil
	}

	if len(ports) != p.allocationSize {
		panic(fmt.Sprintf("Unexpected number of ports returned. Expected: %d. Actual number returned: %d.", p.allocationSize, len(ports)))
	}

	for _, port := range ports {
		// Check that the returned port is within the range of ports managed by the struct.
		if port < p.startingPort || port > p.maxPort {
			panic(fmt.Sprintf("Encountered unexpected port: %d", port))
		}

		if p.portAvailability[port] == true {
			panic(fmt.Sprintf("Port %d is already marked as available.", port))
		}

		p.portAvailability[port] = true
		p.availablePorts = append(p.availablePorts, port)
	}

	p.log.Debug("Returned %d ports. Currently %d/%d ports are allocated.", len(ports), p.NumPortsAllocated(),
		p.totalNumPorts)

	return nil
}
